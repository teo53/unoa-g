-- ============================================
-- UNO A - Celebrations (Birthdays + Milestones)
-- Version: 1.0.0
-- ============================================
-- Privacy: Only month/day stored (no year).
-- Consent: Explicit toggle + timestamp.
-- Idempotent: UNIQUE constraints prevent duplicate events.

-- 1. Fan Celebrations (birthday registration per channel)
CREATE TABLE IF NOT EXISTS public.fan_celebrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  channel_id UUID NOT NULL REFERENCES channels(id) ON DELETE CASCADE,

  -- Birthday (month/day only for privacy â€” no year)
  birth_month INT CHECK (birth_month BETWEEN 1 AND 12),
  birth_day INT CHECK (birth_day BETWEEN 1 AND 31),

  -- Visibility consent
  birthday_visible BOOLEAN DEFAULT false,
  visibility_consent_at TIMESTAMPTZ,

  -- Subscription milestone tracking
  subscription_started_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),

  UNIQUE(user_id, channel_id)
);

CREATE INDEX IF NOT EXISTS idx_fan_celebrations_birthday
  ON fan_celebrations(channel_id, birth_month, birth_day)
  WHERE birthday_visible = true;
CREATE INDEX IF NOT EXISTS idx_fan_celebrations_user
  ON fan_celebrations(user_id);

ALTER TABLE fan_celebrations ENABLE ROW LEVEL SECURITY;

-- Fan can manage own rows
CREATE POLICY "Users can manage own celebrations"
  ON fan_celebrations FOR ALL
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- Creator can see visible celebrations in own channel
CREATE POLICY "Creators can view visible celebrations"
  ON fan_celebrations FOR SELECT
  USING (
    birthday_visible = true
    AND EXISTS (
      SELECT 1 FROM channels
      WHERE id = fan_celebrations.channel_id AND artist_id = auth.uid()
    )
  );


-- 2. Celebration Events (generated by scheduler)
CREATE TABLE IF NOT EXISTS public.celebration_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id UUID NOT NULL REFERENCES channels(id) ON DELETE CASCADE,
  fan_celebration_id UUID NOT NULL REFERENCES fan_celebrations(id) ON DELETE CASCADE,

  -- Event type
  event_type TEXT NOT NULL CHECK (event_type IN (
    'birthday', 'milestone_50', 'milestone_100', 'milestone_365', 'custom'
  )),

  -- Scheduling (KST date)
  due_date DATE NOT NULL,

  -- Status
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'sent', 'skipped', 'expired')),

  -- Payload for template rendering
  payload JSONB NOT NULL DEFAULT '{}',

  -- Link to sent message
  message_id UUID REFERENCES messages(id),

  created_at TIMESTAMPTZ DEFAULT now(),
  sent_at TIMESTAMPTZ,

  -- Idempotent: one event per type per fan per day
  UNIQUE(channel_id, fan_celebration_id, event_type, due_date)
);

CREATE INDEX IF NOT EXISTS idx_celebration_events_due
  ON celebration_events(channel_id, due_date, status)
  WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS idx_celebration_events_channel
  ON celebration_events(channel_id, event_type);

ALTER TABLE celebration_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Creators can view own channel celebration events"
  ON celebration_events FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM channels
      WHERE id = celebration_events.channel_id AND artist_id = auth.uid()
    )
  );

CREATE POLICY "Creators can update own channel celebration events"
  ON celebration_events FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM channels
      WHERE id = celebration_events.channel_id AND artist_id = auth.uid()
    )
  );


-- 3. Celebration Templates
CREATE TABLE IF NOT EXISTS public.celebration_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id UUID REFERENCES channels(id) ON DELETE CASCADE,  -- NULL = system default

  event_type TEXT NOT NULL CHECK (event_type IN (
    'birthday', 'milestone_50', 'milestone_100', 'milestone_365', 'custom'
  )),

  -- Template with variables: {nickname}, {day_count}, {artist_name}
  template_text TEXT NOT NULL,

  is_default BOOLEAN DEFAULT false,
  sort_order INT DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE celebration_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view default templates"
  ON celebration_templates FOR SELECT
  USING (
    channel_id IS NULL
    OR EXISTS (
      SELECT 1 FROM channels
      WHERE id = celebration_templates.channel_id AND artist_id = auth.uid()
    )
  );

CREATE POLICY "Creators can manage own templates"
  ON celebration_templates FOR ALL
  USING (
    channel_id IS NOT NULL
    AND EXISTS (
      SELECT 1 FROM channels
      WHERE id = celebration_templates.channel_id AND artist_id = auth.uid()
    )
  );


-- 4. Default templates (system-wide)
INSERT INTO celebration_templates (channel_id, event_type, template_text, is_default, sort_order) VALUES
  (NULL, 'birthday', '{nickname}ë‹˜, ìƒì¼ ì¶•í•˜í•´ìš”! ðŸŽ‚ðŸŽ‰ ì˜¤ëŠ˜ í•˜ë£¨ í–‰ë³µí•˜ê²Œ ë³´ë‚´ì„¸ìš”~', true, 1),
  (NULL, 'birthday', 'ìƒì¼ ì¶•í•˜í•©ë‹ˆë‹¤ {nickname}! ðŸ¥³ í•­ìƒ ì‘ì›í•´ì¤˜ì„œ ê³ ë§ˆì›Œìš” ðŸ’•', true, 2),
  (NULL, 'birthday', '{nickname}ë‹˜~ í•´í”¼ ë²„ìŠ¤ë°ì´! ðŸŽ ì•žìœ¼ë¡œë„ í•¨ê»˜í•´ìš”!', true, 3),
  (NULL, 'milestone_50', '{nickname}ë‹˜, ë²Œì¨ {day_count}ì¼! í•¨ê»˜í•´ì¤˜ì„œ ê°ì‚¬í•´ìš” ðŸ’', true, 1),
  (NULL, 'milestone_50', '{day_count}ì¼ì§¸ í•¨ê»˜í•˜ê³  ìžˆì–´ìš” {nickname}! ì•žìœ¼ë¡œë„ ìž˜ ë¶€íƒí•´ìš” ðŸ™', true, 2),
  (NULL, 'milestone_100', '{nickname}ë‹˜ê³¼ í•¨ê»˜í•œ {day_count}ì¼ ðŸŽŠ 100ì¼ ì¶•í•˜í•´ìš”!', true, 1),
  (NULL, 'milestone_100', '100ì¼ì´ë¼ë‹ˆ! {nickname}ë‹˜ ì •ë§ ê°ì‚¬í•´ìš” ðŸ’– {artist_name}ì´/ê°€ í•­ìƒ ê³ì— ìžˆì„ê²Œìš”!', true, 2),
  (NULL, 'milestone_365', '{nickname}ë‹˜, 1ë…„ì´ë‚˜ í•¨ê»˜í•´ì£¼ì…¨ì–´ìš”! ðŸ¥° ì •ë§ ê°ì‚¬í•©ë‹ˆë‹¤!', true, 1),
  (NULL, 'milestone_365', '365ì¼! {nickname}ë‹˜ê³¼ í•¨ê»˜í•œ 1ë…„ì€ ì •ë§ íŠ¹ë³„í–ˆì–´ìš” ðŸŒŸ {artist_name} ë“œë¦¼ ðŸ’•', true, 2);


-- 5. Generate daily celebrations (idempotent)
CREATE OR REPLACE FUNCTION generate_daily_celebrations(p_channel_id UUID)
RETURNS INT
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_kst_date DATE;
  v_count INT := 0;
  v_milestone_days INT[] := ARRAY[50, 100, 365];
  v_milestone TEXT;
  v_day_diff INT;
  v_rec RECORD;
BEGIN
  v_kst_date := (now() AT TIME ZONE 'Asia/Seoul')::date;

  -- Birthday events
  INSERT INTO celebration_events (channel_id, fan_celebration_id, event_type, due_date, payload)
  SELECT
    fc.channel_id,
    fc.id,
    'birthday',
    v_kst_date,
    jsonb_build_object(
      'nickname', COALESCE(up.display_name, 'íŒ¬'),
      'user_id', fc.user_id,
      'tier', COALESCE(s.tier, 'BASIC')
    )
  FROM fan_celebrations fc
  JOIN user_profiles up ON up.id = fc.user_id
  LEFT JOIN subscriptions s ON s.user_id = fc.user_id
    AND s.channel_id = fc.channel_id AND s.is_active = true
  WHERE fc.channel_id = p_channel_id
    AND fc.birthday_visible = true
    AND fc.birth_month = EXTRACT(MONTH FROM v_kst_date)
    AND fc.birth_day = EXTRACT(DAY FROM v_kst_date)
  ON CONFLICT (channel_id, fan_celebration_id, event_type, due_date) DO NOTHING;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  -- Milestone events
  FOR v_rec IN
    SELECT
      fc.id as fc_id,
      fc.channel_id,
      fc.user_id,
      COALESCE(up.display_name, 'íŒ¬') as nickname,
      COALESCE(s.tier, 'BASIC') as tier,
      EXTRACT(DAY FROM v_kst_date::timestamp - fc.subscription_started_at::timestamp)::int as days
    FROM fan_celebrations fc
    JOIN user_profiles up ON up.id = fc.user_id
    LEFT JOIN subscriptions s ON s.user_id = fc.user_id
      AND s.channel_id = fc.channel_id AND s.is_active = true
    WHERE fc.channel_id = p_channel_id
  LOOP
    FOREACH v_day_diff IN ARRAY v_milestone_days
    LOOP
      IF v_rec.days = v_day_diff THEN
        v_milestone := 'milestone_' || v_day_diff;
        INSERT INTO celebration_events (
          channel_id, fan_celebration_id, event_type, due_date, payload
        ) VALUES (
          v_rec.channel_id,
          v_rec.fc_id,
          v_milestone,
          v_kst_date,
          jsonb_build_object(
            'nickname', v_rec.nickname,
            'user_id', v_rec.user_id,
            'day_count', v_day_diff,
            'tier', v_rec.tier
          )
        )
        ON CONFLICT (channel_id, fan_celebration_id, event_type, due_date) DO NOTHING;
        v_count := v_count + 1;
      END IF;
    END LOOP;
  END LOOP;

  RETURN v_count;
END;
$$;


-- 6. Get today's celebration queue for creator
CREATE OR REPLACE FUNCTION get_celebration_queue(p_channel_id UUID)
RETURNS JSONB
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result JSONB;
  v_kst_date DATE;
BEGIN
  v_kst_date := (now() AT TIME ZONE 'Asia/Seoul')::date;

  -- Verify creator owns channel
  IF NOT EXISTS (
    SELECT 1 FROM channels WHERE id = p_channel_id AND artist_id = auth.uid()
  ) THEN
    RETURN jsonb_build_object('error', 'not_channel_owner');
  END IF;

  -- Generate any missing events for today
  PERFORM generate_daily_celebrations(p_channel_id);

  SELECT jsonb_build_object(
    'kst_date', v_kst_date,
    'birthday_count', (
      SELECT COUNT(*) FROM celebration_events
      WHERE channel_id = p_channel_id AND due_date = v_kst_date
        AND event_type = 'birthday' AND status = 'pending'
    ),
    'milestone_count', (
      SELECT COUNT(*) FROM celebration_events
      WHERE channel_id = p_channel_id AND due_date = v_kst_date
        AND event_type LIKE 'milestone_%' AND status = 'pending'
    ),
    'events', COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'event_id', ce.id,
          'event_type', ce.event_type,
          'nickname', ce.payload->>'nickname',
          'day_count', ce.payload->'day_count',
          'tier', ce.payload->>'tier',
          'status', ce.status
        ) ORDER BY ce.event_type, (ce.payload->>'nickname')
      )
      FROM celebration_events ce
      WHERE ce.channel_id = p_channel_id
        AND ce.due_date = v_kst_date
        AND ce.status = 'pending'
    ), '[]'::jsonb)
  ) INTO v_result;

  RETURN v_result;
END;
$$;


-- 7. Expire old celebration events (cron cleanup)
CREATE OR REPLACE FUNCTION cleanup_expired_celebrations()
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
  v_count INT;
BEGIN
  UPDATE celebration_events
  SET status = 'expired'
  WHERE status = 'pending'
    AND due_date < (now() AT TIME ZONE 'Asia/Seoul')::date - INTERVAL '7 days';
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

// src/notion-api.ts
import {
  getBlockCollectionId,
  getPageContentBlockIds,
  parsePageId,
  uuidToId
} from "notion-utils";
import { ofetch } from "ofetch";
import pMap from "p-map";
var NotionAPI = class {
  _apiBaseUrl;
  _authToken;
  _activeUser;
  _userTimeZone;
  _ofetchOptions;
  constructor({
    apiBaseUrl = "https://www.notion.so/api/v3",
    authToken,
    activeUser,
    userTimeZone = "America/New_York",
    ofetchOptions
  } = {}) {
    this._apiBaseUrl = apiBaseUrl;
    this._authToken = authToken;
    this._activeUser = activeUser;
    this._userTimeZone = userTimeZone;
    this._ofetchOptions = ofetchOptions;
  }
  async getPage(pageId, {
    concurrency = 3,
    fetchMissingBlocks = true,
    fetchCollections = true,
    signFileUrls = true,
    chunkLimit = 100,
    chunkNumber = 0,
    throwOnCollectionErrors = false,
    collectionReducerLimit = 999,
    fetchRelationPages = false,
    ofetchOptions
  } = {}) {
    const page = await this.getPageRaw(pageId, {
      chunkLimit,
      chunkNumber,
      ofetchOptions
    });
    const recordMap = page?.recordMap;
    if (!recordMap?.block) {
      throw new Error(`Notion page not found "${uuidToId(pageId)}"`);
    }
    recordMap.collection = recordMap.collection ?? {};
    recordMap.collection_view = recordMap.collection_view ?? {};
    recordMap.notion_user = recordMap.notion_user ?? {};
    recordMap.collection_query = {};
    recordMap.signed_urls = {};
    if (fetchMissingBlocks) {
      while (true) {
        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(
          (id) => !recordMap.block[id]
        );
        if (!pendingBlockIds.length) {
          break;
        }
        const newBlocks = await this.getBlocks(
          pendingBlockIds,
          ofetchOptions
        ).then((res) => res.recordMap.block);
        recordMap.block = { ...recordMap.block, ...newBlocks };
      }
    }
    const contentBlockIds = getPageContentBlockIds(recordMap);
    if (fetchCollections) {
      const allCollectionInstances = contentBlockIds.flatMap((blockId) => {
        const block = recordMap.block[blockId]?.value;
        const collectionId = block && (block.type === "collection_view" || block.type === "collection_view_page") && getBlockCollectionId(block, recordMap);
        if (collectionId) {
          const spaceId = block?.space_id;
          return block.view_ids?.map((collectionViewId) => ({
            collectionId,
            collectionViewId,
            spaceId
          }));
        } else {
          return [];
        }
      });
      await pMap(
        allCollectionInstances,
        async (collectionInstance) => {
          const { collectionId, collectionViewId, spaceId } = collectionInstance;
          const collectionView = recordMap.collection_view[collectionViewId]?.value;
          try {
            const collectionData = await this.getCollectionData(
              collectionId,
              collectionViewId,
              collectionView,
              {
                limit: collectionReducerLimit,
                spaceId,
                ofetchOptions
              }
            );
            recordMap.block = {
              ...recordMap.block,
              ...collectionData.recordMap.block
            };
            recordMap.collection = {
              ...recordMap.collection,
              ...collectionData.recordMap.collection
            };
            recordMap.collection_view = {
              ...recordMap.collection_view,
              ...collectionData.recordMap.collection_view
            };
            recordMap.notion_user = {
              ...recordMap.notion_user,
              ...collectionData.recordMap.notion_user
            };
            recordMap.collection_query[collectionId] = {
              ...recordMap.collection_query[collectionId],
              [collectionViewId]: collectionData.result?.reducerResults
            };
          } catch (err) {
            console.warn(
              "NotionAPI collectionQuery error",
              { pageId, collectionId, collectionViewId },
              err.message
            );
            if (throwOnCollectionErrors) {
              throw err;
            } else {
              console.error(err);
            }
          }
        },
        {
          concurrency
        }
      );
    }
    if (signFileUrls) {
      await this.addSignedUrls({ recordMap, contentBlockIds, ofetchOptions });
    }
    if (fetchRelationPages) {
      const newBlocks = await this.fetchRelationPages(recordMap, ofetchOptions);
      recordMap.block = { ...recordMap.block, ...newBlocks };
    }
    return recordMap;
  }
  fetchRelationPages = async (recordMap, ofetchOptions) => {
    const maxIterations = 10;
    for (let i = 0; i < maxIterations; ++i) {
      const relationPageIdsThisIteration = /* @__PURE__ */ new Set();
      for (const blockId of Object.keys(recordMap.block)) {
        const blockValue = recordMap.block[blockId]?.value;
        if (blockValue?.parent_table === "collection" && blockValue?.parent_id) {
          const collection = recordMap.collection[blockValue.parent_id]?.value;
          if (collection?.schema) {
            const ids = this.extractRelationPageIdsFromBlock(
              blockValue,
              collection.schema
            );
            for (const id of ids) relationPageIdsThisIteration.add(id);
          }
        }
      }
      const missingRelationPageIds = Array.from(
        relationPageIdsThisIteration
      ).filter((id) => !recordMap.block[id]?.value);
      if (!missingRelationPageIds.length) break;
      try {
        const newBlocks = await this.getBlocks(
          missingRelationPageIds,
          ofetchOptions
        ).then((res) => res.recordMap.block);
        recordMap.block = { ...recordMap.block, ...newBlocks };
      } catch (err) {
        console.warn(
          "NotionAPI getBlocks error during fetchRelationPages:",
          err
        );
      }
    }
    return recordMap.block;
  };
  extractRelationPageIdsFromBlock = (blockValue, collectionSchema) => {
    const pageIds = /* @__PURE__ */ new Set();
    for (const propertyId of Object.keys(blockValue.properties || {})) {
      const schema = collectionSchema[propertyId];
      if (schema?.type === "relation") {
        const decorations = blockValue.properties[propertyId];
        if (Array.isArray(decorations)) {
          for (const decoration of decorations) {
            if (Array.isArray(decoration) && decoration.length > 1 && decoration[0] === "\u2023") {
              const pagePointer = decoration[1]?.[0];
              if (Array.isArray(pagePointer) && pagePointer.length > 1 && pagePointer[0] === "p") {
                pageIds.add(pagePointer[1]);
              }
            }
          }
        }
      }
    }
    return pageIds;
  };
  async addSignedUrls({
    recordMap,
    contentBlockIds,
    ofetchOptions = {}
  }) {
    recordMap.signed_urls = {};
    if (!contentBlockIds) {
      contentBlockIds = getPageContentBlockIds(recordMap);
    }
    const allFileInstances = contentBlockIds.flatMap((blockId) => {
      const block = recordMap.block[blockId]?.value;
      if (block && (block.type === "pdf" || block.type === "audio" || block.type === "image" && block.file_ids?.length || block.type === "video" || block.type === "file" || block.type === "page")) {
        const source = block.type === "page" ? block.format?.page_cover : block.properties?.source?.[0]?.[0];
        if (source) {
          if (source.includes("secure.notion-static.com") || source.includes("prod-files-secure") || source.includes("attachment:")) {
            return {
              permissionRecord: {
                table: "block",
                id: block.id
              },
              url: source
            };
          }
          return [];
        }
      }
      return [];
    });
    if (allFileInstances.length > 0) {
      try {
        const { signedUrls } = await this.getSignedFileUrls(
          allFileInstances,
          ofetchOptions
        );
        if (signedUrls.length === allFileInstances.length) {
          for (const [i, file] of allFileInstances.entries()) {
            const signedUrl = signedUrls[i];
            if (!signedUrl) continue;
            const blockId = file.permissionRecord.id;
            if (!blockId) continue;
            recordMap.signed_urls[blockId] = signedUrl;
          }
        }
      } catch (err) {
        console.warn("NotionAPI getSignedfileUrls error", err);
      }
    }
  }
  async getPageRaw(pageId, {
    ofetchOptions,
    chunkLimit = 100,
    chunkNumber = 0
  } = {}) {
    const parsedPageId = parsePageId(pageId);
    if (!parsedPageId) {
      throw new Error(`invalid notion pageId "${pageId}"`);
    }
    const body = {
      pageId: parsedPageId,
      limit: chunkLimit,
      chunkNumber,
      cursor: { stack: [] },
      verticalColumns: false
    };
    return this.fetch({
      endpoint: "loadPageChunk",
      body,
      ofetchOptions
    });
  }
  async getCollectionData(collectionId, collectionViewId, collectionView, {
    limit = 999,
    searchQuery = "",
    userTimeZone = this._userTimeZone,
    loadContentCover = true,
    spaceId,
    ofetchOptions
  } = {}) {
    const type = collectionView?.type;
    const isBoardType = type === "board";
    const groupBy = isBoardType ? collectionView?.format?.board_columns_by : collectionView?.format?.collection_group_by;
    let filters = [];
    if (collectionView?.format?.property_filters) {
      filters = collectionView.format?.property_filters.map(
        (filterObj) => {
          return {
            filter: filterObj?.filter?.filter,
            property: filterObj?.filter?.property
          };
        }
      );
    }
    if (collectionView?.query2?.filter?.filters) {
      filters.push(...collectionView.query2.filter.filters);
    }
    let loader = {
      type: "reducer",
      reducers: {
        collection_group_results: {
          type: "results",
          limit,
          loadContentCover
        }
      },
      sort: [],
      ...collectionView?.query2,
      filter: {
        filters,
        operator: "and"
      },
      searchQuery,
      userTimeZone
    };
    if (groupBy) {
      const groups = collectionView?.format?.board_columns || collectionView?.format?.collection_groups || [];
      const iterators = [isBoardType ? "board" : "group_aggregation", "results"];
      const operators = {
        checkbox: "checkbox_is",
        url: "string_starts_with",
        text: "string_starts_with",
        select: "enum_is",
        multi_select: "enum_contains",
        created_time: "date_is_within",
        undefined: "is_empty"
      };
      const reducersQuery = {};
      for (const group of groups) {
        const {
          property,
          value: { value, type: type2 }
        } = group;
        for (const iterator of iterators) {
          const iteratorProps = iterator === "results" ? {
            type: iterator,
            limit
          } : {
            type: "aggregation",
            aggregation: {
              aggregator: "count"
            }
          };
          const isUncategorizedValue = value === void 0;
          const isDateValue = value?.range;
          const queryLabel = isUncategorizedValue ? "uncategorized" : isDateValue ? value.range?.start_date || value.range?.end_date : value?.value || value;
          const queryValue = !isUncategorizedValue && (isDateValue || value?.value || value);
          reducersQuery[`${iterator}:${type2}:${queryLabel}`] = {
            ...iteratorProps,
            filter: {
              operator: "and",
              filters: [
                {
                  property,
                  filter: {
                    operator: !isUncategorizedValue ? operators[type2] : "is_empty",
                    ...!isUncategorizedValue && {
                      value: {
                        type: "exact",
                        value: queryValue
                      }
                    }
                  }
                }
              ]
            }
          };
        }
      }
      const reducerLabel = isBoardType ? "board_columns" : `${type}_groups`;
      loader = {
        type: "reducer",
        reducers: {
          [reducerLabel]: {
            type: "groups",
            version: "v2",
            groupBy,
            ...collectionView?.query2?.filter && {
              filter: collectionView?.query2?.filter
            },
            groupSortPreference: groups.map((group) => ({
              property: group?.property,
              value: {
                type: group?.value?.type,
                value: group?.value?.value
              }
            })),
            limit
          },
          ...reducersQuery
        },
        ...collectionView?.query2,
        searchQuery,
        userTimeZone,
        //TODO: add filters here
        filter: {
          filters,
          operator: "and"
        }
      };
    }
    const headers = {};
    if (spaceId) {
      headers["x-notion-space-id"] = spaceId;
    }
    return this.fetch({
      endpoint: "queryCollection",
      body: {
        collection: {
          id: collectionId
        },
        collectionView: {
          id: collectionViewId
        },
        source: {
          type: "collection",
          id: collectionId
        },
        loader
      },
      headers,
      ofetchOptions: {
        timeout: 6e4,
        ...ofetchOptions,
        params: {
          // TODO: spread ofetchOptions?.searchParams
          src: "initial_load"
        }
      }
    });
  }
  async getUsers(userIds, ofetchOptions) {
    return this.fetch({
      endpoint: "getRecordValues",
      body: {
        requests: userIds.map((id) => ({ id, table: "notion_user" }))
      },
      ofetchOptions
    });
  }
  async getBlocks(blockIds, ofetchOptions) {
    return this.fetch({
      endpoint: "syncRecordValuesMain",
      body: {
        requests: blockIds.map((blockId) => ({
          // TODO: when to use table 'space' vs 'block'?
          table: "block",
          id: blockId,
          version: -1
        }))
      },
      ofetchOptions
    });
  }
  async getSignedFileUrls(urls, ofetchOptions) {
    return this.fetch({
      endpoint: "getSignedFileUrls",
      body: {
        urls
      },
      ofetchOptions
    });
  }
  async search(params, ofetchOptions) {
    const body = {
      type: "BlocksInAncestor",
      source: "quick_find_public",
      ancestorId: parsePageId(params.ancestorId),
      sort: {
        field: "relevance"
      },
      limit: params.limit || 20,
      query: params.query,
      filters: {
        isDeletedOnly: false,
        isNavigableOnly: false,
        excludeTemplates: true,
        requireEditPermissions: false,
        includePublicPagesWithoutExplicitAccess: true,
        ancestors: [],
        createdBy: [],
        editedBy: [],
        lastEditedTime: {},
        createdTime: {},
        ...params.filters
      }
    };
    return this.fetch({
      endpoint: "search",
      body,
      ofetchOptions
    });
  }
  async fetch({
    endpoint,
    body,
    ofetchOptions,
    headers: clientHeaders
  }) {
    const headers = {
      ...clientHeaders,
      ...this._ofetchOptions?.headers,
      ...ofetchOptions?.headers,
      "Content-Type": "application/json"
    };
    if (this._authToken) {
      headers.cookie = `token_v2=${this._authToken}`;
    }
    if (this._activeUser) {
      headers["x-notion-active-user-header"] = this._activeUser;
    }
    const url = `${this._apiBaseUrl}/${endpoint}`;
    const res = ofetch(url, {
      method: "POST",
      mode: "no-cors",
      ...this._ofetchOptions,
      ...ofetchOptions,
      body,
      headers
    });
    return res;
  }
};
export {
  NotionAPI
};
//# sourceMappingURL=index.js.map
{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\n//import ky, { type Options as OfetchOptions } from 'ky'\n\nimport type * as notion from 'notion-types'\nimport {\n  getBlockCollectionId,\n  getPageContentBlockIds,\n  parsePageId,\n  uuidToId\n} from 'notion-utils'\nimport { type FetchOptions as OfetchOptions, ofetch } from 'ofetch'\nimport pMap from 'p-map'\n\nimport type * as types from './types'\n\n/**\n * Main Notion API client.\n */\nexport class NotionAPI {\n  private readonly _apiBaseUrl: string\n  private readonly _authToken?: string\n  private readonly _activeUser?: string\n  private readonly _userTimeZone: string\n  private readonly _ofetchOptions?: OfetchOptions\n\n  constructor({\n    apiBaseUrl = 'https://www.notion.so/api/v3',\n    authToken,\n    activeUser,\n    userTimeZone = 'America/New_York',\n    ofetchOptions\n  }: {\n    apiBaseUrl?: string\n    authToken?: string\n    userLocale?: string\n    userTimeZone?: string\n    activeUser?: string\n    ofetchOptions?: OfetchOptions\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl\n    this._authToken = authToken\n    this._activeUser = activeUser\n    this._userTimeZone = userTimeZone\n    this._ofetchOptions = ofetchOptions\n  }\n\n  public async getPage(\n    pageId: string,\n    {\n      concurrency = 3,\n      fetchMissingBlocks = true,\n      fetchCollections = true,\n      signFileUrls = true,\n      chunkLimit = 100,\n      chunkNumber = 0,\n      throwOnCollectionErrors = false,\n      collectionReducerLimit = 999,\n      fetchRelationPages = false,\n      ofetchOptions\n    }: {\n      concurrency?: number\n      fetchMissingBlocks?: boolean\n      fetchCollections?: boolean\n      signFileUrls?: boolean\n      chunkLimit?: number\n      chunkNumber?: number\n      throwOnCollectionErrors?: boolean\n      collectionReducerLimit?: number\n      fetchRelationPages?: boolean\n      ofetchOptions?: OfetchOptions\n    } = {}\n  ): Promise<notion.ExtendedRecordMap> {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      ofetchOptions\n    })\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\n\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\n    }\n\n    // ensure that all top-level maps exist\n    recordMap.collection = recordMap.collection ?? {}\n    recordMap.collection_view = recordMap.collection_view ?? {}\n    recordMap.notion_user = recordMap.notion_user ?? {}\n\n    // additional mappings added for convenience\n    // note: these are not native notion objects\n    recordMap.collection_query = {}\n    recordMap.signed_urls = {}\n\n    if (fetchMissingBlocks) {\n      while (true) {\n        // fetch any missing content blocks\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        )\n\n        if (!pendingBlockIds.length) {\n          break\n        }\n\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          ofetchOptions\n        ).then((res) => res.recordMap.block)\n\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      }\n    }\n\n    const contentBlockIds = getPageContentBlockIds(recordMap)\n\n    // Optionally fetch all data for embedded collections and their associated views.\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\n    // This is really convenient in order to ensure that all data needed for a given\n    // Notion page is readily available for use cases involving server-side rendering\n    // and edge caching.\n    if (fetchCollections) {\n      const allCollectionInstances: Array<{\n        collectionId: string\n        collectionViewId: string\n        spaceId?: string\n      }> = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId]?.value\n        const collectionId =\n          block &&\n          (block.type === 'collection_view' ||\n            block.type === 'collection_view_page') &&\n          getBlockCollectionId(block, recordMap)\n\n        if (collectionId) {\n          const spaceId = block?.space_id\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId,\n            spaceId\n          }))\n        } else {\n          return []\n        }\n      })\n\n      // fetch data for all collection view instances\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId, spaceId } = collectionInstance\n          const collectionView =\n            recordMap.collection_view[collectionViewId]?.value\n\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                limit: collectionReducerLimit,\n                spaceId,\n                ofetchOptions\n              }\n            )\n\n            // await fs.writeFile(\n            //   `${collectionId}-${collectionViewId}.json`,\n            //   JSON.stringify(collectionData.result, null, 2)\n            // )\n\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            }\n\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            }\n\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            }\n\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            }\n\n            recordMap.collection_query![collectionId] = {\n              ...recordMap.collection_query![collectionId],\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\n            }\n          } catch (err: any) {\n            // It's possible for public pages to link to private collections,\n            // in which case Notion returns a 400 error. This may be that or it\n            // may be something else.\n            console.warn(\n              'NotionAPI collectionQuery error',\n              { pageId, collectionId, collectionViewId },\n              err.message\n            )\n\n            if (throwOnCollectionErrors) {\n              throw err\n              // throw new Error(\n              //   `NotionAPI error fetching collectionQuery for page \"${pageId}\" collection \"${collectionId}\" view \"${collectionViewId}\": ${err.message}`,\n              //   {\n              //     cause: err\n              //   }\n              // )\n            } else {\n              console.error(err)\n            }\n          }\n        },\n        {\n          concurrency\n        }\n      )\n    }\n\n    // Optionally fetch signed URLs for any embedded files.\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\n    // because it is preferable for many use cases as opposed to making these API calls\n    // lazily from the client-side.\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, ofetchOptions })\n    }\n\n    if (fetchRelationPages) {\n      const newBlocks = await this.fetchRelationPages(recordMap, ofetchOptions)\n      recordMap.block = { ...recordMap.block, ...newBlocks }\n    }\n\n    return recordMap\n  }\n\n  fetchRelationPages = async (\n    recordMap: notion.ExtendedRecordMap,\n    ofetchOptions: OfetchOptions | undefined\n  ): Promise<notion.BlockMap> => {\n    const maxIterations = 10\n\n    for (let i = 0; i < maxIterations; ++i) {\n      const relationPageIdsThisIteration = new Set<string>()\n\n      for (const blockId of Object.keys(recordMap.block)) {\n        const blockValue = recordMap.block[blockId]?.value\n        if (\n          blockValue?.parent_table === 'collection' &&\n          blockValue?.parent_id\n        ) {\n          const collection = recordMap.collection[blockValue.parent_id]?.value\n          if (collection?.schema) {\n            const ids = this.extractRelationPageIdsFromBlock(\n              blockValue,\n              collection.schema\n            )\n            for (const id of ids) relationPageIdsThisIteration.add(id)\n          }\n        }\n      }\n\n      const missingRelationPageIds = Array.from(\n        relationPageIdsThisIteration\n      ).filter((id) => !recordMap.block[id]?.value)\n\n      if (!missingRelationPageIds.length) break\n\n      try {\n        const newBlocks = await this.getBlocks(\n          missingRelationPageIds,\n          ofetchOptions\n        ).then((res) => res.recordMap.block)\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      } catch (err: any) {\n        console.warn(\n          'NotionAPI getBlocks error during fetchRelationPages:',\n          err\n        )\n        // consider break or delay/retry here\n      }\n    }\n\n    return recordMap.block\n  }\n\n  extractRelationPageIdsFromBlock = (\n    blockValue: any,\n    collectionSchema: any\n  ): Set<string> => {\n    const pageIds = new Set<string>()\n\n    for (const propertyId of Object.keys(blockValue.properties || {})) {\n      const schema = collectionSchema[propertyId]\n      if (schema?.type === 'relation') {\n        const decorations = blockValue.properties[propertyId]\n        if (Array.isArray(decorations)) {\n          for (const decoration of decorations) {\n            if (\n              Array.isArray(decoration) &&\n              decoration.length > 1 &&\n              decoration[0] === 'â€£'\n            ) {\n              const pagePointer = decoration[1]?.[0]\n              if (\n                Array.isArray(pagePointer) &&\n                pagePointer.length > 1 &&\n                pagePointer[0] === 'p'\n              ) {\n                pageIds.add(pagePointer[1])\n              }\n            }\n          }\n        }\n      }\n    }\n    return pageIds\n  }\n\n  public async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    ofetchOptions = {}\n  }: {\n    recordMap: notion.ExtendedRecordMap\n    contentBlockIds?: string[]\n    ofetchOptions?: OfetchOptions\n  }) {\n    recordMap.signed_urls = {}\n\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap)\n    }\n\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (\n        block &&\n        (block.type === 'pdf' ||\n          block.type === 'audio' ||\n          (block.type === 'image' && block.file_ids?.length) ||\n          block.type === 'video' ||\n          block.type === 'file' ||\n          block.type === 'page')\n      ) {\n        const source =\n          block.type === 'page'\n            ? block.format?.page_cover\n            : block.properties?.source?.[0]?.[0]\n        // console.log(block, source)\n\n        if (source) {\n          if (\n            source.includes('secure.notion-static.com') ||\n            source.includes('prod-files-secure') ||\n            source.includes('attachment:')\n          ) {\n            return {\n              permissionRecord: {\n                table: 'block',\n                id: block.id\n              },\n              url: source\n            }\n          }\n\n          return []\n        }\n      }\n\n      return []\n    })\n\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          ofetchOptions\n        )\n\n        if (signedUrls.length === allFileInstances.length) {\n          for (const [i, file] of allFileInstances.entries()) {\n            const signedUrl = signedUrls[i]\n            if (!signedUrl) continue\n\n            const blockId = file.permissionRecord.id\n            if (!blockId) continue\n\n            recordMap.signed_urls[blockId] = signedUrl\n          }\n        }\n      } catch (err) {\n        console.warn('NotionAPI getSignedfileUrls error', err)\n      }\n    }\n  }\n\n  public async getPageRaw(\n    pageId: string,\n    {\n      ofetchOptions,\n      chunkLimit = 100,\n      chunkNumber = 0\n    }: {\n      chunkLimit?: number\n      chunkNumber?: number\n      ofetchOptions?: OfetchOptions\n    } = {}\n  ) {\n    const parsedPageId = parsePageId(pageId)\n\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\n    }\n\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    }\n\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'loadPageChunk',\n      body,\n      ofetchOptions\n    })\n  }\n\n  public async getCollectionData(\n    collectionId: string,\n    collectionViewId: string,\n    collectionView?: any,\n    {\n      limit = 999,\n      searchQuery = '',\n      userTimeZone = this._userTimeZone,\n      loadContentCover = true,\n      spaceId,\n      ofetchOptions\n    }: {\n      type?: notion.CollectionViewType\n      limit?: number\n      searchQuery?: string\n      userTimeZone?: string\n      userLocale?: string\n      loadContentCover?: boolean\n      spaceId?: string\n      ofetchOptions?: OfetchOptions\n    } = {}\n  ) {\n    const type = collectionView?.type\n    const isBoardType = type === 'board'\n    const groupBy = isBoardType\n      ? collectionView?.format?.board_columns_by\n      : collectionView?.format?.collection_group_by\n\n    let filters = []\n    if (collectionView?.format?.property_filters) {\n      filters = collectionView.format?.property_filters.map(\n        (filterObj: any) => {\n          //get the inner filter\n          return {\n            filter: filterObj?.filter?.filter,\n            property: filterObj?.filter?.property\n          }\n        }\n      )\n    }\n\n    // Fixes formula filters from not working\n    if (collectionView?.query2?.filter?.filters) {\n      filters.push(...collectionView.query2.filter.filters)\n    }\n\n    let loader: any = {\n      type: 'reducer',\n      reducers: {\n        collection_group_results: {\n          type: 'results',\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      filter: {\n        filters,\n        operator: 'and'\n      },\n      searchQuery,\n      userTimeZone\n    }\n\n    if (groupBy) {\n      const groups =\n        collectionView?.format?.board_columns ||\n        collectionView?.format?.collection_groups ||\n        []\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\n      const operators = {\n        checkbox: 'checkbox_is',\n        url: 'string_starts_with',\n        text: 'string_starts_with',\n        select: 'enum_is',\n        multi_select: 'enum_contains',\n        created_time: 'date_is_within',\n        undefined: 'is_empty'\n      }\n\n      const reducersQuery: Record<string, any> = {}\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type }\n        } = group\n\n        for (const iterator of iterators) {\n          const iteratorProps =\n            iterator === 'results'\n              ? {\n                  type: iterator,\n                  limit\n                }\n              : {\n                  type: 'aggregation',\n                  aggregation: {\n                    aggregator: 'count'\n                  }\n                }\n\n          const isUncategorizedValue = value === undefined\n          const isDateValue = value?.range\n          // TODO: review dates reducers\n          const queryLabel = isUncategorizedValue\n            ? 'uncategorized'\n            : isDateValue\n              ? value.range?.start_date || value.range?.end_date\n              : value?.value || value\n\n          const queryValue =\n            !isUncategorizedValue && (isDateValue || value?.value || value)\n\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: 'and',\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue\n                      ? operators[type as keyof typeof operators]\n                      : 'is_empty',\n                    ...(!isUncategorizedValue && {\n                      value: {\n                        type: 'exact',\n                        value: queryValue\n                      }\n                    })\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\n      loader = {\n        type: 'reducer',\n        reducers: {\n          [reducerLabel]: {\n            type: 'groups',\n            version: 'v2',\n            groupBy,\n            ...(collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            }),\n            groupSortPreference: groups.map((group: any) => ({\n              property: group?.property,\n              value: {\n                type: group?.value?.type,\n                value: group?.value?.value\n              }\n            })),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone,\n        //TODO: add filters here\n        filter: {\n          filters,\n          operator: 'and'\n        }\n      }\n    }\n\n    // if (isBoardType) {\n    //   console.log(\n    //     JSON.stringify(\n    //       {\n    //         collectionId,\n    //         collectionViewId,\n    //         loader,\n    //         groupBy: groupBy || 'NONE',\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\n    //       },\n    //       null,\n    //       2\n    //     )\n    //   )\n    // }\n\n    const headers: any = {}\n    if (spaceId) {\n      headers['x-notion-space-id'] = spaceId\n    }\n\n    return this.fetch<notion.CollectionInstance>({\n      endpoint: 'queryCollection',\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        source: {\n          type: 'collection',\n          id: collectionId\n        },\n        loader\n      },\n      headers,\n      ofetchOptions: {\n        timeout: 60_000,\n        ...ofetchOptions,\n        params: {\n          // TODO: spread ofetchOptions?.searchParams\n          src: 'initial_load'\n        }\n      }\n    })\n  }\n\n  public async getUsers(userIds: string[], ofetchOptions?: OfetchOptions) {\n    return this.fetch<notion.RecordValues<notion.User>>({\n      endpoint: 'getRecordValues',\n      body: {\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\n      },\n      ofetchOptions\n    })\n  }\n\n  public async getBlocks(blockIds: string[], ofetchOptions?: OfetchOptions) {\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'syncRecordValuesMain',\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: 'block',\n          id: blockId,\n          version: -1\n        }))\n      },\n      ofetchOptions\n    })\n  }\n\n  public async getSignedFileUrls(\n    urls: types.SignedUrlRequest[],\n    ofetchOptions?: OfetchOptions\n  ) {\n    return this.fetch<types.SignedUrlResponse>({\n      endpoint: 'getSignedFileUrls',\n      body: {\n        urls\n      },\n      ofetchOptions\n    })\n  }\n\n  public async search(\n    params: notion.SearchParams,\n    ofetchOptions?: OfetchOptions\n  ) {\n    const body = {\n      type: 'BlocksInAncestor',\n      source: 'quick_find_public',\n      ancestorId: parsePageId(params.ancestorId),\n      sort: {\n        field: 'relevance'\n      },\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        includePublicPagesWithoutExplicitAccess: true,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    }\n\n    return this.fetch<notion.SearchResults>({\n      endpoint: 'search',\n      body,\n      ofetchOptions\n    })\n  }\n\n  public async fetch<T>({\n    endpoint,\n    body,\n    ofetchOptions,\n    headers: clientHeaders\n  }: {\n    endpoint: string\n    body: object\n    ofetchOptions?: OfetchOptions\n    headers?: any\n  }): Promise<T> {\n    const headers: any = {\n      ...clientHeaders,\n      ...this._ofetchOptions?.headers,\n      ...ofetchOptions?.headers,\n      'Content-Type': 'application/json'\n    }\n\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`\n    }\n\n    if (this._activeUser) {\n      headers['x-notion-active-user-header'] = this._activeUser\n    }\n\n    const url = `${this._apiBaseUrl}/${endpoint}`\n\n    /*     const res = await ky.post(url, {\n      mode: 'no-cors',\n      ...this._ofetchOptions,\n      ...ofetchOptions,\n      json: body,\n      headers\n    }) */\n\n    // TODO: we're awaiting the first fetch and then separately awaiting\n    // `res.json()` because there seems to be some weird error which repros\n    // sporadically when loading collections where the body is already used.\n    // No idea why, but from my testing, separating these into two separate\n    // steps seems to fix the issue locally for me...\n    // console.log(endpoint, { bodyUsed: res.bodyUsed })\n\n    /* return res.json<T>() */\n    const res = ofetch(url, {\n      method: 'POST',\n      mode: 'no-cors',\n      ...this._ofetchOptions,\n      ...ofetchOptions,\n      body,\n      headers\n    })\n    return res\n  }\n}\n"],"mappings":"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","names":["type"]}
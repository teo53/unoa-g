// src/estimate-page-read-time.ts
import "notion-types";

// src/get-block-title.ts
import "notion-types";

// src/get-block-collection-id.ts
import "notion-types";
function getBlockCollectionId(block, recordMap) {
  var _a, _b, _c, _d, _e, _f, _g;
  const collectionId = block.collection_id || ((_b = (_a = block.format) == null ? void 0 : _a.collection_pointer) == null ? void 0 : _b.id);
  if (collectionId) {
    return collectionId;
  }
  const collectionViewId = (_c = block == null ? void 0 : block.view_ids) == null ? void 0 : _c[0];
  if (collectionViewId) {
    const collectionView = (_e = (_d = recordMap.collection_view) == null ? void 0 : _d[collectionViewId]) == null ? void 0 : _e.value;
    if (collectionView) {
      const collectionId2 = (_g = (_f = collectionView.format) == null ? void 0 : _f.collection_pointer) == null ? void 0 : _g.id;
      return collectionId2;
    }
  }
  return null;
}

// src/get-text-content.ts
var getTextContent = (text) => {
  var _a;
  if (!text) {
    return "";
  } else if (Array.isArray(text)) {
    return (_a = text == null ? void 0 : text.reduce(
      (prev, current) => prev + (current[0] !== "\u204D" && current[0] !== "\u2023" ? current[0] : ""),
      ""
    )) != null ? _a : "";
  } else {
    return text;
  }
};

// src/get-block-title.ts
function getBlockTitle(block, recordMap) {
  var _a, _b;
  if ((_a = block.properties) == null ? void 0 : _a.title) {
    return getTextContent(block.properties.title);
  }
  if (block.type === "collection_view_page" || block.type === "collection_view") {
    const collectionId = getBlockCollectionId(block, recordMap);
    if (collectionId) {
      const collection = (_b = recordMap.collection[collectionId]) == null ? void 0 : _b.value;
      if (collection) {
        return getTextContent(collection.name);
      }
    }
  }
  return "";
}

// src/get-page-table-of-contents.ts
var indentLevels = {
  header: 0,
  sub_header: 1,
  sub_sub_header: 2
};
var getPageTableOfContents = (page, recordMap) => {
  function mapContentToEntries(content) {
    return (content != null ? content : []).map((blockId) => {
      var _a, _b;
      const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;
      if (block) {
        const { type } = block;
        if (type === "header" || type === "sub_header" || type === "sub_sub_header") {
          return {
            id: blockId,
            type,
            text: getTextContent((_b = block.properties) == null ? void 0 : _b.title),
            indentLevel: indentLevels[type]
          };
        }
        if (type === "transclusion_container" || type === "column_list" || type === "column") {
          return mapContentToEntries(block.content);
        }
      }
      return null;
    });
  }
  function flattenResults(results) {
    return results.flatMap((r) => {
      if (r == null) return [];
      return Array.isArray(r) ? flattenResults(r) : [r];
    });
  }
  const toc = flattenResults(mapContentToEntries(page.content));
  const indentLevelStack = [
    {
      actual: -1,
      effective: -1
    }
  ];
  for (const tocItem of toc) {
    const { indentLevel } = tocItem;
    const actual = indentLevel;
    do {
      const prevIndent = indentLevelStack.at(-1);
      const { actual: prevActual, effective: prevEffective } = prevIndent;
      if (actual > prevActual) {
        tocItem.indentLevel = prevEffective + 1;
        indentLevelStack.push({
          actual,
          effective: tocItem.indentLevel
        });
      } else if (actual === prevActual) {
        tocItem.indentLevel = prevEffective;
        break;
      } else {
        indentLevelStack.pop();
      }
    } while (true);
  }
  return toc;
};

// src/estimate-page-read-time.ts
function estimatePageReadTime(block, recordMap, {
  wordsPerMinute = 275,
  imageReadTimeInSeconds = 12
} = {}) {
  const stats = getBlockContentStats(block, recordMap);
  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute;
  const totalImageReadTimeInSeconds = stats.numImages > 10 ? stats.numImages / 2 * (imageReadTimeInSeconds + 3) + (stats.numImages - 10) * 3 : stats.numImages / 2 * (2 * imageReadTimeInSeconds + (1 - stats.numImages));
  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60;
  const totalReadTimeInMinutes = totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes;
  return {
    ...stats,
    totalWordsReadTimeInMinutes,
    totalImageReadTimeInMinutes,
    totalReadTimeInMinutes
  };
}
function estimatePageReadTimeAsHumanizedString(block, recordMap, opts) {
  const estimate = estimatePageReadTime(block, recordMap, opts);
  return humanizeReadTime(estimate.totalReadTimeInMinutes);
}
function getBlockContentStats(block, recordMap) {
  var _a, _b, _c, _d;
  const stats = {
    numWords: 0,
    numImages: 0
  };
  if (!block) {
    return stats;
  }
  for (const childId of block.content || []) {
    const child = (_a = recordMap.block[childId]) == null ? void 0 : _a.value;
    let recurse = false;
    if (!child) continue;
    switch (child.type) {
      case "quote":
      // fallthrough
      case "alias":
      // fallthrough
      case "header":
      // fallthrough
      case "sub_header":
      // fallthrough
      case "sub_sub_header": {
        const title = getBlockTitle(child, recordMap);
        stats.numWords += countWordsInText(title);
        break;
      }
      case "callout":
      // fallthrough
      case "toggle":
      // fallthrough
      case "to_do":
      // fallthrough
      case "bulleted_list":
      // fallthrough
      case "numbered_list":
      // fallthrough
      case "text": {
        const title = getBlockTitle(child, recordMap);
        stats.numWords += countWordsInText(title);
        recurse = true;
        break;
      }
      case "embed":
      // fallthrough
      case "tweet":
      // fallthrough
      case "maps":
      // fallthrough
      case "pdf":
      // fallthrough
      case "figma":
      // fallthrough
      case "typeform":
      // fallthrough
      case "codepen":
      // fallthrough
      case "excalidraw":
      // fallthrough
      case "gist":
      // fallthrough
      case "video":
      // fallthrough
      case "drive":
      // fallthrough
      case "audio":
      // fallthrough
      case "file":
      // fallthrough
      case "image":
        stats.numImages += 1;
        break;
      case "bookmark":
        stats.numImages += 0.25;
        break;
      case "code":
        stats.numImages += 2;
        break;
      case "table":
      // fallthrough
      case "collection_view":
        stats.numImages += 2;
        break;
      case "column":
      // fallthrough
      case "column_list":
      // fallthrough
      case "transclusion_container":
        recurse = true;
        break;
      case "table_of_contents": {
        const page = block;
        if (!page) continue;
        const toc = getPageTableOfContents(page, recordMap);
        for (const tocItem of toc) {
          stats.numWords += countWordsInText(tocItem.text);
        }
        break;
      }
      case "transclusion_reference": {
        const referencePointerId = (_c = (_b = child == null ? void 0 : child.format) == null ? void 0 : _b.transclusion_reference_pointer) == null ? void 0 : _c.id;
        if (!referencePointerId) {
          continue;
        }
        const referenceBlock = (_d = recordMap.block[referencePointerId]) == null ? void 0 : _d.value;
        if (referenceBlock) {
          mergeContentStats(
            stats,
            getBlockContentStats(referenceBlock, recordMap)
          );
        }
        break;
      }
      default:
        break;
    }
    if (recurse) {
      mergeContentStats(stats, getBlockContentStats(child, recordMap));
    }
  }
  return stats;
}
function mergeContentStats(statsA, statsB) {
  statsA.numWords += statsB.numWords;
  statsA.numImages += statsB.numImages;
}
function countWordsInText(text) {
  if (!text) {
    return 0;
  }
  return (text.match(/\w+/g) || []).length;
}
function humanizeReadTime(time) {
  if (time < 0.5) {
    return "less than a minute";
  }
  if (time < 1.5) {
    return "1 minute";
  }
  return `${Math.ceil(time)} minutes`;
}

// src/format-date.ts
var formatDate = (input, { month = "short" } = {}) => {
  const date = new Date(input);
  const monthLocale = date.toLocaleString("en-US", { month });
  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`;
};

// src/format-notion-date-time.ts
var formatNotionDateTime = (datetime) => {
  const dateString = `${datetime.start_date}T${datetime.start_time || "00:00"}+00:00`;
  return formatDate(dateString);
};

// src/get-all-pages-in-space.ts
import "notion-types";
import PQueue from "p-queue";

// src/id-to-uuid.ts
var idToUuid = (id = "") => `${id.slice(0, 8)}-${id.slice(8, 12)}-${id.slice(12, 16)}-${id.slice(
  16,
  20
)}-${id.slice(20)}`;

// src/parse-page-id.ts
var pageIdRe = /\b([\da-f]{32})\b/;
var pageId2Re = /\b([\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12})\b/;
var parsePageId = (id = "", { uuid = true } = {}) => {
  if (!id) return;
  id = id.split("?")[0];
  if (!id) return;
  const match = id.match(pageIdRe);
  if (match) {
    return uuid ? idToUuid(match[1]) : match[1];
  }
  const match2 = id.match(pageId2Re);
  if (match2) {
    return uuid ? match2[1] : match2[1].replaceAll("-", "");
  }
  return;
};

// src/get-all-pages-in-space.ts
async function getAllPagesInSpace(rootPageId, rootSpaceId, getPage, {
  concurrency = 4,
  traverseCollections = true,
  targetPageId,
  maxDepth = Number.POSITIVE_INFINITY
} = {}) {
  const pages = {};
  const pendingPageIds = /* @__PURE__ */ new Set();
  const queue = new PQueue({ concurrency });
  async function processPage(pageId, depth = 0) {
    if (depth > maxDepth) {
      return;
    }
    if (targetPageId && pendingPageIds.has(targetPageId)) {
      return;
    }
    pageId = parsePageId(pageId);
    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {
      pendingPageIds.add(pageId);
      void queue.add(async () => {
        var _a, _b, _c;
        try {
          if (targetPageId && pendingPageIds.has(targetPageId) && pageId !== targetPageId) {
            return;
          }
          const page = await getPage(pageId);
          if (!page) {
            return;
          }
          const spaceId = (_b = (_a = page.block[pageId]) == null ? void 0 : _a.value) == null ? void 0 : _b.space_id;
          if (spaceId) {
            if (!rootSpaceId) {
              rootSpaceId = spaceId;
            } else if (rootSpaceId !== spaceId) {
              return;
            }
          }
          for (const subPageId of Object.keys(page.block).filter((key) => {
            var _a2;
            const block = (_a2 = page.block[key]) == null ? void 0 : _a2.value;
            if (!block || block.alive === false) return false;
            if (block.type !== "page" && block.type !== "collection_view_page") {
              return false;
            }
            if (rootSpaceId && block.space_id && block.space_id !== rootSpaceId) {
              return false;
            }
            return true;
          })) {
            void processPage(subPageId, depth + 1);
          }
          if (traverseCollections) {
            for (const collectionViews of Object.values(
              page.collection_query
            )) {
              for (const collectionData of Object.values(collectionViews)) {
                const blockIds = Array.from(
                  /* @__PURE__ */ new Set([
                    ...((_c = collectionData == null ? void 0 : collectionData.collection_group_results) == null ? void 0 : _c.blockIds) || [],
                    ...collectionData.blockIds || []
                  ])
                );
                if (blockIds.length) {
                  for (const collectionItemId of blockIds) {
                    void processPage(collectionItemId, depth + 1);
                  }
                }
              }
            }
          }
          pages[pageId] = page;
        } catch (err) {
          console.warn(
            "page load error",
            { pageId, spaceId: rootSpaceId },
            err.statusCode,
            err.message
          );
          pages[pageId] = null;
        }
        pendingPageIds.delete(pageId);
      });
    }
  }
  await processPage(rootPageId);
  await queue.onIdle();
  return pages;
}

// src/get-block-icon.ts
import "notion-types";
function getBlockIcon(block, recordMap) {
  var _a, _b, _c;
  if ((_a = block.format) == null ? void 0 : _a.page_icon) {
    return (_b = block.format) == null ? void 0 : _b.page_icon;
  }
  if (block.type === "collection_view_page" || block.type === "collection_view") {
    const collectionId = getBlockCollectionId(block, recordMap);
    if (collectionId) {
      const collection = (_c = recordMap.collection[collectionId]) == null ? void 0 : _c.value;
      if (collection) {
        return collection.icon;
      }
    }
  }
  return null;
}

// src/get-block-parent-page.ts
var getBlockParentPage = (block, recordMap, {
  inclusive = false
} = {}) => {
  var _a, _b;
  let currentRecord = block;
  while (currentRecord) {
    if (inclusive && (currentRecord == null ? void 0 : currentRecord.type) === "page") {
      return currentRecord;
    }
    const parentId = currentRecord.parent_id;
    const parentTable = currentRecord.parent_table;
    if (!parentId) {
      break;
    }
    if (parentTable === "collection") {
      currentRecord = (_a = recordMap.collection[parentId]) == null ? void 0 : _a.value;
    } else {
      currentRecord = (_b = recordMap.block[parentId]) == null ? void 0 : _b.value;
      if ((currentRecord == null ? void 0 : currentRecord.type) === "page") {
        return currentRecord;
      }
    }
  }
  return null;
};

// src/get-canonical-page-id.ts
import "notion-types";

// src/get-page-property.ts
import "notion-types";
function getPageProperty(propertyName, block, recordMap) {
  var _a;
  try {
    if (!block.properties || !Object.keys(recordMap.collection)) {
      return null;
    }
    const collection = (_a = recordMap.collection[block.parent_id]) == null ? void 0 : _a.value;
    if (collection) {
      const propertyNameL = propertyName.toLowerCase();
      const propertyId = Object.keys(collection.schema).find(
        (key) => {
          var _a2, _b;
          return ((_b = (_a2 = collection.schema[key]) == null ? void 0 : _a2.name) == null ? void 0 : _b.toLowerCase()) === propertyNameL;
        }
      );
      if (!propertyId) {
        return null;
      }
      const s = collection.schema[propertyId];
      if (!s) {
        return null;
      }
      const { type } = s;
      const content = getTextContent(block.properties[propertyId]);
      switch (type) {
        case "created_time":
          return block.created_time;
        case "multi_select":
          return content.split(",");
        case "date": {
          const property = block.properties[propertyId];
          const formatDate2 = property[0][1][0][1];
          if (formatDate2.type === "datetime") {
            return (/* @__PURE__ */ new Date(
              `${formatDate2.start_date} ${formatDate2.start_time}`
            )).getTime();
          } else if (formatDate2.type === "date") {
            return new Date(formatDate2.start_date).getTime();
          } else if (formatDate2.type === "datetimerange") {
            const { start_date, start_time, end_date, end_time } = formatDate2;
            const startTime = (/* @__PURE__ */ new Date(`${start_date} ${start_time}`)).getTime();
            const endTime = (/* @__PURE__ */ new Date(`${end_date} ${end_time}`)).getTime();
            return [startTime, endTime];
          } else {
            const startTime = new Date(formatDate2.start_date).getTime();
            const endTime = new Date(formatDate2.end_date).getTime();
            return [startTime, endTime];
          }
        }
        case "checkbox":
          return content === "Yes";
        case "last_edited_time":
          return block.last_edited_time;
        default:
          return content;
      }
    }
  } catch (e) {
  }
  return null;
}

// src/normalize-title.ts
var normalizeTitle = (title) => {
  return (title || "").replaceAll(" ", "-").replaceAll(
    /[^\dA-Za-z\u3000-\u303F\u3041-\u3096\u30A1-\u30FC\u4E00-\u9FFF\uAC00-\uD7AF-]/g,
    ""
  ).replaceAll("--", "-").replace(/-$/, "").replace(/^-/, "").trim().toLowerCase();
};

// src/uuid-to-id.ts
var uuidToId = (uuid) => uuid.replaceAll("-", "");

// src/get-canonical-page-id.ts
var getCanonicalPageId = (pageId, recordMap, { uuid = true } = {}) => {
  var _a;
  if (!pageId || !recordMap) return null;
  const id = uuidToId(pageId);
  const block = (_a = recordMap.block[pageId]) == null ? void 0 : _a.value;
  if (block) {
    const slug = getPageProperty("slug", block, recordMap) || getPageProperty("Slug", block, recordMap) || normalizeTitle(getBlockTitle(block, recordMap));
    if (slug) {
      if (uuid) {
        return `${slug}-${id}`;
      } else {
        return slug;
      }
    }
  }
  return id;
};

// src/get-date-value.ts
var getDateValue = (prop) => {
  if (prop && Array.isArray(prop)) {
    if (prop[0] === "d") {
      return prop[1];
    } else {
      for (const v of prop) {
        const value = getDateValue(v);
        if (value) {
          return value;
        }
      }
    }
  }
  return null;
};

// src/get-page-breadcrumbs.ts
var getPageBreadcrumbs = (recordMap, activePageId) => {
  var _a;
  const blockMap = recordMap.block;
  const breadcrumbs = [];
  let currentPageId = activePageId;
  do {
    const block = (_a = blockMap[currentPageId]) == null ? void 0 : _a.value;
    if (!block) {
      break;
    }
    const title = getBlockTitle(block, recordMap);
    const icon = getBlockIcon(block, recordMap);
    if (!(title || icon)) {
      break;
    }
    breadcrumbs.push({
      block,
      active: currentPageId === activePageId,
      pageId: currentPageId,
      title,
      icon
    });
    const parentBlock = getBlockParentPage(block, recordMap);
    const parentId = parentBlock == null ? void 0 : parentBlock.id;
    if (!parentId) {
      break;
    }
    currentPageId = parentId;
  } while (true);
  breadcrumbs.reverse();
  return breadcrumbs;
};

// src/get-page-content-block-ids.ts
var getPageContentBlockIds = (recordMap, blockId) => {
  const rootBlockId = blockId || Object.keys(recordMap.block)[0];
  const contentBlockIds = /* @__PURE__ */ new Set();
  function addContentBlocks(blockId2) {
    var _a, _b, _c, _d, _e, _f;
    if (contentBlockIds.has(blockId2)) return;
    contentBlockIds.add(blockId2);
    const block = (_a = recordMap.block[blockId2]) == null ? void 0 : _a.value;
    if (!block) return;
    const { content, type, properties, format } = block;
    if (properties) {
      for (const key of Object.keys(properties)) {
        const p = properties[key];
        if (!p) continue;
        for (const d of p) {
          const value2 = (_c = (_b = d == null ? void 0 : d[0]) == null ? void 0 : _b[1]) == null ? void 0 : _c[0];
          if ((value2 == null ? void 0 : value2[0]) === "p" && value2[1]) {
            addContentBlocks(value2[1]);
          }
        }
        const value = (_e = (_d = p == null ? void 0 : p[0]) == null ? void 0 : _d[1]) == null ? void 0 : _e[0];
        if ((value == null ? void 0 : value[0]) === "p" && value[1]) {
          addContentBlocks(value[1]);
        }
      }
    }
    if (format) {
      const referenceId = (_f = format.transclusion_reference_pointer) == null ? void 0 : _f.id;
      if (referenceId) {
        addContentBlocks(referenceId);
      }
    }
    if (!content || !Array.isArray(content)) {
      return;
    }
    if (blockId2 !== rootBlockId) {
      if (type === "page" || type === "collection_view_page") {
        return;
      }
    }
    for (const blockId3 of content) {
      addContentBlocks(blockId3);
    }
  }
  addContentBlocks(rootBlockId);
  return Array.from(contentBlockIds);
};

// src/is-url.ts
import { default as default2 } from "is-url-superb";

// src/get-page-image-urls.ts
var getPageImageUrls = (recordMap, {
  mapImageUrl
}) => {
  const blockIds = Object.keys(recordMap.block);
  const imageUrls = blockIds.flatMap((blockId) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;
    const images = [];
    if (block) {
      if (block.type === "image") {
        const signedUrl = (_b = recordMap.signed_urls) == null ? void 0 : _b[block.id];
        let source = signedUrl || ((_e = (_d = (_c = block.properties) == null ? void 0 : _c.source) == null ? void 0 : _d[0]) == null ? void 0 : _e[0]);
        if (source == null ? void 0 : source.includes("file.notion.so")) {
          source = (_h = (_g = (_f = block.properties) == null ? void 0 : _f.source) == null ? void 0 : _g[0]) == null ? void 0 : _h[0];
        }
        if (source) {
          images.push({
            block,
            url: source
          });
        }
      }
      if ((_i = block.format) == null ? void 0 : _i.page_cover) {
        const source = block.format.page_cover;
        images.push({
          block,
          url: source
        });
      }
      if ((_j = block.format) == null ? void 0 : _j.bookmark_cover) {
        const source = block.format.bookmark_cover;
        images.push({
          block,
          url: source
        });
      }
      if ((_k = block.format) == null ? void 0 : _k.bookmark_icon) {
        const source = block.format.bookmark_icon;
        images.push({
          block,
          url: source
        });
      }
      const pageIcon = getBlockIcon(block, recordMap);
      if (pageIcon && default2(pageIcon)) {
        images.push({
          block,
          url: pageIcon
        });
      }
    }
    return images;
  }).filter(Boolean).map(({ block, url }) => mapImageUrl(url, block)).filter(Boolean);
  return Array.from(new Set(imageUrls));
};

// src/get-page-title.ts
import "notion-types";
function getPageTitle(recordMap) {
  var _a;
  const rootBlockId = Object.keys(recordMap.block)[0];
  if (!rootBlockId) return null;
  const pageBlock = (_a = recordMap.block[rootBlockId]) == null ? void 0 : _a.value;
  if (pageBlock) {
    return getBlockTitle(pageBlock, recordMap);
  }
  return null;
}

// src/get-page-tweet-urls.ts
var getPageTweetUrls = (recordMap) => {
  const blockIds = Object.keys(recordMap.block);
  const tweetUrls = blockIds.map((blockId) => {
    var _a, _b, _c, _d;
    const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;
    if ((block == null ? void 0 : block.type) === "tweet") {
      const tweetUrl = (_d = (_c = (_b = block.properties) == null ? void 0 : _b.source) == null ? void 0 : _c[0]) == null ? void 0 : _d[0];
      if (tweetUrl) {
        return tweetUrl;
      }
    }
  }).filter(Boolean);
  return Array.from(new Set(tweetUrls));
};

// src/get-page-tweet-ids.ts
var getPageTweetIds = (recordMap) => {
  const tweetUrls = getPageTweetUrls(recordMap);
  return tweetUrls.map((url) => {
    try {
      const u = new URL(url);
      const parts = u.pathname.split("/");
      return parts.at(-1);
    } catch (e) {
      return;
    }
  }).filter(Boolean);
};

// src/map-image-url.ts
import "notion-types";
var GIF_REGEXP = /(?:https?:\/\/)?[^\s]+\.gif(?=$|\?|#)/;
var defaultMapImageUrl = (url, block) => {
  if (!url) {
    return void 0;
  }
  if (url.startsWith("data:")) {
    return url;
  }
  if (GIF_REGEXP.test(url)) {
    return url;
  }
  if (url.startsWith("https://images.unsplash.com")) {
    return url;
  }
  try {
    const u = new URL(url);
    if (u.pathname.startsWith("/secure.notion-static.com") && u.hostname.endsWith(".amazonaws.com")) {
      if (u.searchParams.has("X-Amz-Credential") && u.searchParams.has("X-Amz-Signature") && u.searchParams.has("X-Amz-Algorithm")) {
        return url;
      }
    }
    if (u.hostname === "img.notionusercontent.com") {
      return url;
    }
  } catch (e) {
  }
  if (url.startsWith("/images")) {
    url = `https://www.notion.so${url}`;
  }
  url = `https://www.notion.so${url.startsWith("/image") ? url : `/image/${encodeURIComponent(url)}`}`;
  const notionImageUrlV2 = new URL(url);
  let table = block.parent_table === "space" ? "block" : block.parent_table;
  if (table === "collection" || table === "team") {
    table = "block";
  }
  notionImageUrlV2.searchParams.set("table", table);
  notionImageUrlV2.searchParams.set("id", block.id);
  notionImageUrlV2.searchParams.set("cache", "v2");
  url = notionImageUrlV2.toString();
  return url;
};

// src/map-page-url.ts
var defaultMapPageUrl = (rootPageId) => (pageId) => {
  pageId = (pageId || "").replaceAll("-", "");
  if (rootPageId && pageId === rootPageId) {
    return "/";
  } else {
    return `/${pageId}`;
  }
};

// src/merge-record-maps.ts
import "notion-types";
function mergeRecordMaps(recordMapA, recordMapB) {
  const mergedRecordMap = {
    block: {
      ...recordMapA.block,
      ...recordMapB.block
    },
    collection: {
      ...recordMapA.collection,
      ...recordMapB.collection
    },
    collection_view: {
      ...recordMapA.collection_view,
      ...recordMapB.collection_view
    },
    notion_user: {
      ...recordMapA.notion_user,
      ...recordMapB.notion_user
    },
    collection_query: {
      ...recordMapA.collection_query,
      ...recordMapB.collection_query
    },
    signed_urls: {
      ...recordMapA.signed_urls,
      ...recordMapB.signed_urls
    },
    preview_images: {
      ...recordMapA.preview_images,
      ...recordMapB.preview_images
    }
  };
  return mergedRecordMap;
}

// src/normalize-url.ts
import memoize from "memoize";
import normalizeUrlImpl from "normalize-url";
var normalizeUrl = memoize((url) => {
  if (!url) {
    return "";
  }
  try {
    if (url.startsWith("https://www.notion.so/image/")) {
      const u = new URL(url);
      const subUrl = decodeURIComponent(u.pathname.slice("/image/".length));
      const normalizedSubUrl = normalizeUrl(subUrl);
      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`;
      url = u.toString();
    }
    return normalizeUrlImpl(url, {
      stripProtocol: true,
      stripWWW: true,
      stripHash: true,
      stripTextFragment: true,
      removeQueryParameters: true
    });
  } catch (e) {
    return "";
  }
});
export {
  defaultMapImageUrl,
  defaultMapPageUrl,
  estimatePageReadTime,
  estimatePageReadTimeAsHumanizedString,
  formatDate,
  formatNotionDateTime,
  getAllPagesInSpace,
  getBlockCollectionId,
  getBlockIcon,
  getBlockParentPage,
  getBlockTitle,
  getCanonicalPageId,
  getDateValue,
  getPageBreadcrumbs,
  getPageContentBlockIds,
  getPageImageUrls,
  getPageProperty,
  getPageTableOfContents,
  getPageTitle,
  getPageTweetIds,
  getPageTweetUrls,
  getTextContent,
  idToUuid,
  default2 as isUrl,
  mergeRecordMaps,
  normalizeTitle,
  normalizeUrl,
  parsePageId,
  uuidToId
};
//# sourceMappingURL=index.js.map